name: Auto Sync with Upstream
on:
  schedule:
    - cron: '0 0 * * *'  # Run every day at midnight UTC
  workflow_dispatch:     # Can also be triggered manually from GitHub Actions tab

permissions:
  contents: write    # NEEDED FOR RELEASES!
  actions: read

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      # Step 1: Download our repository to the GitHub runner
      - name: Checkout repository
        uses: actions/checkout@v3
        
      # Step 2: Set up Git with bot credentials for commits
      - name: Configure Git
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          
      # Step 3: Add the original repo as "upstream" and download its latest changes
      - name: Add upstream and fetch
        run: |
          git remote add upstream https://github.com/aldinokemal/go-whatsapp-web-multidevice.git
          git fetch upstream
          
      # Step 4: Merge new code from upstream but preserve our custom README.md
      - name: Merge upstream changes but keep our files
        run: |
          cp README.md README_backup.md              # Backup our custom README
          git merge upstream/main --no-edit --allow-unrelated-histories -X theirs || true  # Merge new code (ignore conflicts)
          cp README_backup.md README.md              # Restore our custom README
          rm README_backup.md                        # Clean up backup file
          git checkout upstream/main -- readme.md    # Get original readme as reference
          mv readme.md INTRO.md                      # Rename it to INTRO.md
          
      # Step 5: Copy releases from upstream repository to ours if they are new
      - name: Sync releases
        run: |
          # Get the latest release tag from the upstream repository
          LATEST_UPSTREAM_TAG=$(gh api repos/aldinokemal/go-whatsapp-web-multidevice/releases/latest --jq '.tag_name')
          
          if [ -z "$LATEST_UPSTREAM_TAG" ] || [ "$LATEST_UPSTREAM_TAG" == "null" ]; then
            echo "Could not fetch latest release tag from upstream. Exiting."
            exit 1
          fi
          
          echo "Latest upstream release tag is: $LATEST_UPSTREAM_TAG"

          # Check if a release with this tag already exists in our repository.
          # The command 'gh release view' will fail if the tag does not exist.
          if gh release view "$LATEST_UPSTREAM_TAG" --repo "$GITHUB_REPOSITORY" >/dev/null 2>&1; then
            # If the command succeeds, the release already exists.
            echo "Release '$LATEST_UPSTREAM_TAG' already exists in this repository. No action needed."
          else
            # If the command fails, the release does not exist, so we create it.
            echo "Release '$LATEST_UPSTREAM_TAG' not found. Creating new release."
            gh release create "$LATEST_UPSTREAM_TAG" \
              --repo "$GITHUB_REPOSITORY" \
              --title "Release $LATEST_UPSTREAM_TAG" \
              --notes "Automatically synced from upstream repository" \
              --latest
            echo "Successfully created release '$LATEST_UPSTREAM_TAG'."
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      # Step 6: Save all changes and push to our repository
      - name: Commit and push changes
        run: |
          git add .                                                              # Add all changes
          git commit -m "Auto-sync: Code updated, README preserved, INTRO.md updated" || exit 0  # Commit (or skip if no changes)
          git push                                                               # Push to our GitHub repository
